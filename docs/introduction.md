# lua-ray プロジェクト紹介

**lua-ray** は、C++ の高いパフォーマンスと Lua の柔軟性を融合させた、実験的なレイトレーシングレンダラーです。

レンダリングのコアエンジンには **Intel Embree** を採用しています。
**Intel Embree** は、Intel が開発した高性能なレイ・トレーシング・カーネル・ライブラリで、映画制作や科学可視化などのプロフェッショナルな現場で標準的に使用されています。非常に高速な BVH (Bounding Volume Hierarchy) 構築とレイ交差判定を提供するため、自前で実装する場合と比べて圧倒的なパフォーマンスを実現しつつ、開発者はレンダリングアルゴリズムそのものに集中することができます。

本プロジェクトは、この Embree を WebAssembly (WASM) 上でも動作させ、ブラウザで実行可能なクロスプラットフォーム設計となっています。

## 主な特徴とアーキテクチャ

### 1. Lua スクリプティングとライブコーディング

本プロジェクトの最大の特徴は、レイトレーシングロジックの制御に **Lua 5.4** を採用している点です。

*   **再ビルドなしで実行可能**:
    *   シーン定義やマテリアル設定はすべて Lua スクリプトとして記述されています。そのため、アプリケーション全体（C++部分）を再コンパイルすることなく、スクリプトを編集して「リロード」するだけで、即座にレンダリング結果（シーンやロジック変更）を反映させることができます。これにより、試行錯誤が容易な「ライブコーディング」環境を実現しています。

*   **Lua の Float 化**:
    *   通常、Lua の数値型は `double` (倍精度浮動小数点数) ですが、本プロジェクトではレンダリングパフォーマンスとメモリ効率、および GPU/SIMD との親和性を考慮し、**`float` (単精度浮動小数点数)** を使用するように Lua 自体にパッチを当ててビルドしています。
    *   **パッチの自動適用**: ビルド時に `patches/lua-single-float.patch` を自動的に適用する仕組みを CMake で構築しており、手動でのソースコード修正は不要です。

### 2. 高度なマルチスレッドレンダリング

パフォーマンスを最大限に引き出すため、洗練されたマルチスレッドアーキテクチャを採用しています。

*   **タイルベースの並列処理**:
    *   画面を小さなブロック（タイル）に分割し、複数のワーカースレッドが並列してレンダリングを行います。
    *   各ワーカーは共有キューから動的にブロックを取得し、担当するタイルに対して**排他的に**描画を行います。これにより、スレッド間の競合（ロック）を最小限に抑えつつ、負荷分散を自動的に最適化しています（複雑な部分は時間がかかり、単純な部分はすぐに終わるため、早く終わったスレッドが次のタイルを取りに行く）。

    ```
    Screen (Dynamic Blocks)      Worker Threads
    +----+----+----+----+
    | 1  | 2  | 3  | 4  |  <--- Thread A (Processing Row 1)
    +----+----+----+----+
    | 5  | 6  | 7  | 8  |  <--- Thread B (Processing Row 2)
    +----+----+----+----+
    ...                        ... (Threads C, D...)
    ```
    *(各ブロックは動的に空いているスレッドに割り当てられます)*

*   **ライフサイクル: `setup` と `start` の関係**:
    *   効率的なリソース管理とスレッド運用のために、初期化フェーズを明確に分離しています。
    *   **`setup(scene, data)`**: シーンロード時に**メインスレッドで1回だけ**呼び出されます。ここでは、スレッドセーフではない **Embree シーンの構築**（ジオメトリの生成、BVHの構築）を行います。
    *   **`start(scene, data)`**: レンダリング開始時に**各ワーカースレッドごとに**呼び出されます。ここでは、**ワーカースレッドの初期化処理**（スレッドローカルな変数の設定、カメラの初期化、乱数生成器のシード設定など）を行います。
    *   この分離により、「Embree シーンの構築は一度で済ませつつ、各スレッドが独立して並列計算を開始できる」効率的かつ安全な構造を実現しています。

    ```
    Main Thread (App)                Worker Threads (x N)
    -----------------                --------------------
           |
       [ setup() ]  --> (Scene/BVH Build: Once)
           |
           +--------------------------> [ start() ] (Init)
           |                              |
           +--------------------------> [ start() ] (Init)
           |                              |
           :                            [ Render Loop ]
       (UI Update)                        (Get Tile -> Trace -> Store)
    ```

    ```lua
    -- シーンスクリプトの例（scenes/example.lua）
    local M = {}
    local scene = nil

    -- setup: メインスレッドで1回だけ実行
    function M.setup(scene_obj, app_data)
        -- ジオメトリの追加やBVHの構築など
        scene_obj:add_sphere(0, 0, -5, 1) 
        scene_obj:commit()
    end

    -- start: 各ワーカースレッドの開始時に実行
    function M.start(scene_obj, app_data)
        scene = scene_obj -- スレッドローカルな変数に保存
        -- カメラの初期化やスレッドローカルな変数の準備
        local width = app_data:width()
        local height = app_data:height()
        init_camera(width, height)
    end

    -- shade: 各ピクセルごとの処理（並列実行）
    function M.shade(app_data, x, y)
        local ray = generate_camera_ray(x, y)
        local hit = scene:intersect(ray)
        if hit then
            app_data:set_pixel(x, y, 255, 255, 255) -- 白
        else
            app_data:set_pixel(x, y, 0, 0, 0) -- 黒
        end
    end
    
    return M
    ```

*   **JSONシリアライズによる堅牢なマテリアルコピー**:
    *   本プロジェクトでは、マルチスレッド環境を実現するために **各ワーカースレッドごとに独立した Lua State (メモリ空間)** を持たせています。そのため、Luaのテーブルなどのデータ構造をそのままスレッド間で共有・コピーすることはできません。
    *   この問題を解決するため、`setup` (メインスレッド) で定義されたマテリアルやオブジェクトデータを一度 **JSON 文字列にシリアライズ** し、それを `start` (各ワーカースレッド) で受け取ってデシリアライズすることで、データの複製を実現しています。
    *   この手法により、複雑な Lua テーブルの「完全なディープコピー」をシンプルかつ確実に実現しています。参照共有によるデータ競合や副作用を根本から排除し、非常に高い安定性を確保しています。また、この処理は初期化フェーズでのみ行われるため、レンダリングパフォーマンスへの影響はありません。

    ```lua

    -- メインスレッド (M.setup 内)
    -- マテリアル定義を含むテーブルを作成
    local material_data = {
        ["metal"] = { type = "lambertian", albedo = {0.8, 0.8, 0.8} },
        ["glass"] = { type = "dielectric", ref_idx = 1.5 }
    }
    
    -- JSONにシリアライズして app_data に保存
    -- これにより、メインスレッドからワーカースレッドへ文字列としてデータを受け渡す
    local json = require("lib.json")
    local json_str = json.encode(material_data)
    app_data:set_string("materials", json_str)

    -- ワーカースレッド (M.start 内)
    -- app_data から JSON 文字列を取得してデシリアライズ
    local json = require("lib.json")
    local json_str = app_data:get_string("materials")
    if json_str and json_str ~= "" then
        M.materials = json.decode(json_str)
    end
    
    -- 各ワーカーは独立したメモリ空間上の materials テーブルを参照する
    local mat = M.materials["metal"] 
    ```

### 3. WebAssembly (WASM) 対応

モダンな Web 技術を活用し、デスクトップアプリと同等の機能をブラウザ上で提供します。

*   **Emscripten の活用**:
    *   C++ で書かれたコードベース全体を Emscripten を使用して WebAssembly にコンパイルしています。これにより、ブラウザ上でネイティブに近いパフォーマンスで動作します。

*   **Embree の WASM ビルド**:
    *   本来は高度な SIMD 命令（AVXなど）を多用する Intel Embree ライブラリを、WebAssembly 環境向けにビルドして統合しています。これにより、Web 上でも高品質なレイトレーシングアクセラレーションを利用可能にしています。

*   **Web Workers**:
    *   ブラウザ上でも `pthread` の代わりに Web Workers を用いたマルチスレッドレンダリングを実現しており、UI をフリーズさせることなく重い計算を実行可能です。

### 4. その他の技術的ハイライト

*   **ポストエフェクトパイプライン**:
    *   レンダリング完了後に実行されるポストプロセス処理（フィルタリングなど）も独立したステージとして実装されており、これも同様にマルチスレッド（タイル分割）で高速に処理されます。

*   **ImGui 連携**:
    *   パラメータ調整やデバッグ情報の表示などの UI も Lua から `app.configure` やコールバックを通じて動的に制御可能です。

*   **安全なリソース管理**:
    *   シーン切り替えやアプリケーション終了時には、実行中のワーカーを安全に停止（terminate）し、リソースリークを防ぐ仕組みが組み込まれています。

## 技術スタックまとめ

| コンポーネント | 技術 | 備考 |
|---|---|---|
| **言語** | C++, Lua 5.4 | Lua は Float パッチ適用済み |
| **コアエンジン** | Intel Embree 4.4.0 | WASM ビルド対応 |
| **ウィンドウ/入力** | SDL3 | クロスプラットフォーム |
| **GUI** | Dear ImGui | Lua バインディング経由で操作 |
| **Web ビルド** | Emscripten | Web Workers 対応 |

## 今後の展望

**lua-ray** は現在も積極的に開発が進められています。ロードマップに含まれる主な機能は以下の通りです。

*   **Relaxed SIMD のサポート**:
    *   WebAssembly の新しい `relaxed-simd` プロポーザルに対応し、特定のブラウザ環境でさらなる高速化を目指します。

*   **glTF フォーマットへの対応**:
    *   業界標準の 3D モデルフォーマットである glTF (GL Transmission Format) の読み込みをサポートし、より複雑でリッチなシーンをレンダリング可能にします。

*   **テクスチャマッピング**:
    *   現在はプロシージャルなマテリアルが主ですが、画像テクスチャのサポートを追加し、UVマッピングによる詳細な表面表現を実現する予定です。
